
# Решение.

Происходит загрузка класса "JvmComprehension" через систему загрузчика классов (ClassLoader),
состоящую из трёх уровней загрузчиков (Bootstrap ClassLoader, Platform ClassLoader, Application ClassLoader).
Потом проходит этап связывания: проверка кода и ссылок на другие классы. на этой стадии начнётся загрузка других классов.
Далее - стадия инициализации с загрузкой всех статических сущностей (при наличии).
Загрузка других классов (Object, Integer, System) происходит аналогично.
Все данные о классах (имена, поля, методы, а также константы) загружаются в область памяти Metaspace.

При вызове метода main (или любого другого) в стеке (Stack Memory) выделяется кадр памяти для него.
* строка 1. При создании примитивной переменной "i" в кадре метода "main" создаётся значение зтой переменной.
* строка 2. При создании класса "Object" в области памяти heap создаётся область памяти для всех его полей.
Переменная "o" (экземпляр класса "Object") находится в кадре main области Stack памяти и содержит ссылку на сам объект в heap.

* строка 3. Аналогично при создании ссылочной переменной "ii" её значение (ссылка на значение этого класса) находится в кадре метода "main" стек-памяти, а описание класса "Integer" - в области heap.

* строка 4. При вызове метода "printAll" создаётся соответствующий кадр в стеке.
Там же создаются значения параметров этого метода ("o", "i", "ii"). Ссылаются они также на heap.

* строка 5. Переменные, созданные внутри этого метода ("uselessVar") также находятся внутри кадра "printAll" стека. При этом описание класса "Integer" хранится в области heap памяти.

*строка 6. При вызове метода "System.out.println" создаётся новый кадр в стеке. (Видимо, т.к. функция "сложносочинённая", то будет отдельные кадры для каждого составляющего метода).
В этом кадре будут находиться ссылки на параметры этого метода "i", "ii", а также
на результат выпонения метода "o.toString()", который при своём выполнении аналогично создаёт кадр в стеке для своего выполнения.

После завершения выполнения функции кадр стека освобождается (удаляется). Сначала это произойдёт с методом "o.toString()",
затем - "System.out.println". Далее завершится "printAll".

*строка 7. Управление вернётся в метод "main". При выполнении метода "System.out.println" также создаётся новый кадр в стеке.
Внутри кадра будет находится передаваемый в метод строковый параметр "finished" (ссылка на него в heap).
В области heap памяти будет находится описание ссылочного класса String.

Так как операторов больше нет, то далее стек последовательно очищается.

P.S. На столь короткой программе работа сборщика мусора представляется нецелесообразной.



